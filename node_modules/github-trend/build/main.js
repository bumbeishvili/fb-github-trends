var request = require("request");
var cheerio = require("cheerio");
var yaml = require("js-yaml");
var RE_HREF_SCRAPE = /^\/([^\/]+)\/([^\/]+)$/;
var Scraper = (function () {
    function Scraper(config) {
        this.config = config || {};
        this.cache = null;
    }
    Scraper.prototype.fetchTrendPage = function (lang_name) {
        var opts = {
            url: "https://github.com/trending"
        };
        if (lang_name) {
            opts.url += "?l=" + lang_name;
        }
        if (this.config.proxy) {
            opts.proxy = this.config.proxy;
        }
        return new Promise(function (resolve, reject) {
            request(opts, function (err, res, body) {
                if (err) {
                    reject(err);
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(new Error("Invalid status: " + res.statusCode));
                    return;
                }
                resolve(body);
            });
        });
    };
    Scraper.prototype.scrapeTrendingRepos = function (lang_name) {
        return this.fetchTrendPage(lang_name).then(function (html) {
            var dom = cheerio.load(html);
            return dom(".repo-list h3 a")
                .toArray()
                .map(function (a) {
                    var href = a.attribs["href"];
                    var match = href.match(RE_HREF_SCRAPE);
                    if (!match) {
                        console.log("Invalid repo: " + href);
                    }
                    return {
                        owner: match[1],
                        name: match[2],
                    };
                });
        });
    };

    Scraper.prototype.scrapeTrendingReposFullInfo = function (lang_name) {
        return this.fetchTrendPage(lang_name).then(function (html) {
            var dom = cheerio.load(html);
            return dom(".repo-list li")
                .toArray()
                .map(function (li, i) {
                    var result = {
                        index: i,
                        name: null,
                        owner: null,
                        description: null,
                        language: null,
                        allStars: null,
                        todaysStars: null,
                    }
                    //extract owner and repo name
                    var domElem = dom(li);
                    var a = domElem.find('h3 a').toArray()[0];

                    var href = a.attribs["href"];
                    var match = href.match(RE_HREF_SCRAPE);

                    if (!match) {
                        console.log("Invalid repo: " + href);
                    }

                    result.owner = match[1];
                    result.name = match[2];

                    //extract description
                    var p = domElem.find('p').toArray()[0];
                    if (p) {
                        result.description = p.children[0].data
                    }

                    //extract programming language
                    var lang = domElem.find('[itemprop="programmingLanguage"]').toArray()[0];
                    if (lang) {
                        result.language = lang.children[0].data
                    }

                    //extract all stars
                    var allStars = domElem.find('[aria-label="star"]').toArray()[0].parent.children[2].data;
                    if (allStars) {
                        allStars = allStars.trim();
                    }

                    //extract todays stars
                    var todaysStars = domElem.find('.text-gray span:last-child').toArray()[0];
                    if (todaysStars) {
                        result.todaysStars = todaysStars.children[2].data
                    }


                    //clean result
                    var emptyStringmatcher = /^\s+|\s+$/g;

                    var keys = Object.keys(result);

                    keys.forEach(k => {
                        if (typeof result[k] === 'string' || result[k] instanceof String) {
                            result[k] = result[k].replace(emptyStringmatcher, '');
                        }
                    });

                    return result;
                });
        });
    };

    Scraper.prototype.fetchLanguageYAML = function () {
        var _this = this;
        if (this.cache !== null) {
            return Promise.resolve(this.cache);
        }
        return new Promise(function (resolve, reject) {
            var opts = {
                url: "https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml"
            };
            if (_this.config.proxy) {
                opts.proxy = _this.config.proxy;
            }
            request(opts, function (err, res, body) {
                if (err) {
                    reject(err);
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(new Error("Invalid status: " + res.statusCode));
                    return;
                }
                var langs = yaml.safeLoad(body);
                _this.cache = langs;
                resolve(langs);
            });
        });
    };
    Scraper.prototype.scrapeLanguageColors = function () {
        return this.fetchLanguageYAML().then(function (langs) {
            var result = {};
            for (var name_1 in langs) {
                var lang = langs[name_1];
                if (!lang.color) {
                    continue;
                }
                result[name_1.toLowerCase()] = lang.color;
                if (lang.aliases !== undefined) {
                    for (var _i = 0, _a = lang.aliases; _i < _a.length; _i++) {
                        var alias = _a[_i];
                        result[alias.toLowerCase()] = lang.color;
                    }
                }
            }
            return result;
        });
    };
    Scraper.prototype.scrapeLanguageNames = function () {
        return this.fetchLanguageYAML().then(function (langs) {
            var result = [];
            for (var name_2 in langs) {
                result.push(name_2);
                var lang = langs[name_2];
                if (!lang.color) {
                    continue;
                }
                if (lang.aliases !== undefined) {
                    Array.prototype.push.apply(result, lang.aliases);
                }
            }
            return result;
        });
    };
    return Scraper;
})();
exports.Scraper = Scraper;
var Client = (function () {
    function Client(config, token) {
        this.scraper = new Scraper(config);
        this.token = token || null;
    }
    Client.prototype.fetchGetAPI = function (repo) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var headers = {
                "User-Agent": "request",
                "Accept": "application/vnd.github.v3+json"
            };
            if (_this.token) {
                headers['Authorization'] = 'token ' + _this.token;
            }
            var opts = {
                url: "https://api.github.com/repos/" + repo.owner + "/" + repo.name,
                headers: headers
            };
            if (_this.scraper.config.proxy) {
                opts.proxy = _this.scraper.config.proxy;
            }
            request(opts, function (err, res, body) {
                if (err) {
                    reject(err);
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(new Error("Invalid status: " + res.statusCode));
                    return;
                }
                try {
                    resolve(JSON.parse(body));
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    };
    Client.prototype.fetchTrending = function (lang) {
        var _this = this;
        return this.scraper.scrapeTrendingRepos(lang).then(function (repos) {
            var promises = [];
            for (var _i = 0; _i < repos.length; _i++) {
                var repo = repos[_i];
                promises.push(_this.fetchGetAPI(repo));
            }
            return Promise.all(promises);
        });
    };
    Client.prototype.fetchAppendingReadme = function (repo) {
        var _this = this;
        return new Promise(function (resolve) {
            var readme_url = repo['html_url'] + '/blob/' + repo['default_branch'] + '/README.md';
            var opts = {
                url: readme_url,
                method: 'HEAD',
            };
            if (_this.scraper.config.proxy) {
                opts.proxy = _this.scraper.config.proxy;
            }
            request(opts, function (err, res, _) {
                if (err) {
                    resolve(repo);
                    return;
                }
                if (res.statusCode !== 200) {
                    resolve(repo);
                    return;
                }
                repo['readme_url'] = readme_url;
                resolve(repo);
            });
        });
    };
    Client.prototype.fetchTrendingWithReadme = function (lang) {
        var _this = this;
        return this.fetchTrending(lang).then(function (repos) {
            var promises = [];
            for (var _i = 0; _i < repos.length; _i++) {
                var repo = repos[_i];
                promises.push(_this.fetchAppendingReadme(repo));
            }
            return Promise.all(promises);
        });
    };
    Client.prototype.fetchTrendingsWithReadme = function (langs) {
        var promises = [];
        for (var _i = 0; _i < langs.length; _i++) {
            var lang = langs[_i];
            promises.push(this.fetchTrendingWithReadme(lang));
        }
        return Promise.all(promises)
            .then(function (trendings) {
                var result = {};
                for (var idx in langs) {
                    result[langs[idx]] = trendings[idx];
                }
                return result;
            });
    };
    Client.prototype.fetchTrendings = function (langs) {
        var promises = [];
        for (var _i = 0; _i < langs.length; _i++) {
            var lang = langs[_i];
            promises.push(this.fetchTrending(lang));
        }
        return Promise.all(promises)
            .then(function (trendings) {
                var result = {};
                for (var idx in langs) {
                    result[langs[idx]] = trendings[idx];
                }
                return result;
            });
    };
    return Client;
})();
exports.Client = Client;
//# sourceMappingURL=main.js.map